/*! by @vlucendo -- http://vlucendo.com */
!function(u){function e(e){for(var n,t,o=e[0],a=e[1],r=e[2],i=0,s=[];i<o.length;i++)t=o[i],l[t]&&s.push(l[t][0]),l[t]=0;for(n in a)Object.prototype.hasOwnProperty.call(a,n)&&(u[n]=a[n]);for(f&&f(e);s.length;)s.shift()();return m.push.apply(m,r||[]),c()}function c(){for(var e,n=0;n<m.length;n++){for(var t=m[n],o=!0,a=1;a<t.length;a++){var r=t[a];0!==l[r]&&(o=!1)}o&&(m.splice(n--,1),e=i(i.s=t[0]))}return e}var t={},l={0:0},m=[];function i(e){if(t[e])return t[e].exports;var n=t[e]={i:e,l:!1,exports:{}};return u[e].call(n.exports,n,n.exports,i),n.l=!0,n.exports}i.m=u,i.c=t,i.d=function(e,n,t){i.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)i.d(t,o,function(e){return n[e]}.bind(null,o));return t},i.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(n,"a",n),n},i.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},i.p="";var n=window.webpackJsonp=window.webpackJsonp||[],o=n.push.bind(n);n.push=e,n=n.slice();for(var a=0;a<n.length;a++)e(n[a]);var f=o;m.push([34,1]),c()}([,,,,,,,,,,,,,,,function(e,n){e.exports=function(e){return'<canvas></canvas><div class="info">Based on <a href="http://process.variable.io/post/159447918296/catching-up-with-houdini-by-bringing-pex-up-to" target="_blank">this video</a> by <a href="http://variable.io" target="_blank">variable studio</a>.</div>'}},function(e,n){e.exports="precision highp float;\nprecision highp int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nconst float PackUpscale = 256. / 255.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v )\n{\n    vec4 r = vec4( fract( v * PackFactors ), v );\n    r.yzw -= r.xyz * ShiftRight8;\n    return r * PackUpscale;\n}\n\nvoid main()\n{\n    gl_FragColor = packDepthToRGBA(gl_FragCoord.z);\n}\n"},function(e,n){e.exports="precision highp float;\nprecision highp int;\nattribute vec2 uv;\nattribute vec3 position;\nattribute vec3 normal;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nattribute vec3 offset;\n\nuniform vec3 mousePosition;\nuniform float touchRadius;\nuniform float touchForce;\nuniform float time;\nuniform float mouseSpeed;\n\nvoid main()\n{\n    vec3 wPos = (modelMatrix * vec4(position, 1.0)).xyz + offset;\n    vec3 wCenter = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz + offset;\n    float d = 3.0;\n    vec3 wAuto = vec3(sin(time * 20.0) * d - sin(time) * d * 0.357, sin(time * 15.0 + 3.0) * d - sin(time * 25.0 - 2.45454), sin(time * 20.0 + 3.0) * 1.0);\n    vec3 mouseVector0 = wCenter.xyz - wAuto;\n    float mouseDist0 = 1.0 - smoothstep(0.0, touchRadius * 0.8, length(mouseVector0));\n    float disp0 = mouseDist0 * touchForce * 1.3;\n    vec3 influence0 = normalize(mouseVector0) * disp0;\n    wPos += influence0;\n    vec3 mouseVector = wCenter.xyz - mousePosition;\n    float mouseDist = (1.0 - smoothstep(0.0, touchRadius, length(mouseVector))) * mouseSpeed;\n    float disp = mouseDist * touchForce;\n    vec3 influence = normalize(mouseVector) * disp;\n    wPos += influence;\n    gl_Position = projectionMatrix * viewMatrix * vec4(wPos, 1.0);\n}\n"},,,,,function(e,n){e.exports="precision highp float;\nprecision highp int;\nattribute vec2 uv;\nattribute vec3 position;\nattribute vec3 normal;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nuniform float bgRotation;\nvarying vec2 vUv;\n\nvec2 transformUV(vec2 uv, float a[9]) {\n    vec3 u = vec3(uv, 1.0);\n    mat3 mo1 = mat3(\n    1, 0, -a[7], 0, 1, -a[8], 0, 0, 1);\n    mat3 mo2 = mat3(\n    1, 0, a[7], 0, 1, a[8], 0, 0, 1);\n    mat3 mt = mat3(\n    1, 0, -a[0], 0, 1, -a[1], 0, 0, 1);\n    mat3 mh = mat3(\n    1, a[2], 0, a[3], 1, 0, 0, 0, 1);\n    mat3 mr = mat3(\n    cos(a[4]), sin(a[4]), 0, -sin(a[4]), cos(a[4]), 0, 0, 0, 1);\n    mat3 ms = mat3(\n    1.0 / a[5], 0, 0, 0, 1.0 / a[6], 0, 0, 0, 1);\n    u = u * mt;\n    u = u * mh;\n    u = u * mo1;\n    u = u * mr;\n    u = u * mo2;\n    u = u * mo1;\n    u = u * ms;\n    u = u * mo2;\n    return u.xy;\n}\nvec2 rotateUV(vec2 uv, float r) {\n    float a[9];\n    a[0] = 0.0;\n    a[1] = 0.0;\n    a[2] = 0.0;\n    a[3] = 0.0;\n    a[4] = r;\n    a[5] = 1.0;\n    a[6] = 1.0;\n    a[7] = 0.5;\n    a[8] = 0.5;\n    return transformUV(uv, a);\n}\nvec2 translateUV(vec2 uv, vec2 translate) {\n    float a[9];\n    a[0] = translate.x;\n    a[1] = translate.y;\n    a[2] = 0.0;\n    a[3] = 0.0;\n    a[4] = 0.0;\n    a[5] = 1.0;\n    a[6] = 1.0;\n    a[7] = 0.5;\n    a[8] = 0.5;\n    return transformUV(uv, a);\n}\nvec2 scaleUV(vec2 uv, vec2 scale) {\n    float a[9];\n    a[0] = 0.0;\n    a[1] = 0.0;\n    a[2] = 0.0;\n    a[3] = 0.0;\n    a[4] = 0.0;\n    a[5] = scale.x;\n    a[6] = scale.y;\n    a[7] = 0.5;\n    a[8] = 0.5;\n    return transformUV(uv, a);\n}\nvec2 scaleUV(vec2 uv, vec2 scale, vec2 origin) {\n    float a[9];\n    a[0] = 0.0;\n    a[1] = 0.0;\n    a[2] = 0.0;\n    a[3] = 0.0;\n    a[4] = 0.0;\n    a[5] = scale.x;\n    a[6] = scale.y;\n    a[7] = origin.x;\n    a[8] = origin.x;\n    return transformUV(uv, a);\n}\n\nvoid main() {\n    vUv = rotateUV(uv, bgRotation);\n    gl_Position = vec4(position, 1.0);\n}\n"},function(e,n){e.exports="\nprecision highp float;\nprecision highp int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nvarying vec2 vUv;\n\nuniform vec3 colorBg1;\nuniform vec3 colorBg2;\n\n#ifndef PI\n    #define PI 3.141592653589793\n#endif\n\n#ifndef HALF_PI\n    #define HALF_PI 1.5707963267948966\n#endif\n\nfloat backInOut(float t) {\n    float f = t < 0.5\n    ? 2.0 * t\n    : 1.0 - (2.0 * t - 1.0);\n    float g = pow(f, 3.0) - f * sin(f * PI);\n    return t < 0.5\n    ? 0.5 * g\n    : 0.5 * (1.0 - g) + 0.5;\n}\nfloat backIn(float t) {\n    return pow(t, 3.0) - t * sin(t * PI);\n}\nfloat backOut(float t) {\n    float f = 1.0 - t;\n    return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\n}\nfloat bounceOut(float t) {\n    const float a = 4.0 / 11.0;\n    const float b = 8.0 / 11.0;\n    const float c = 9.0 / 10.0;\n    const float ca = 4356.0 / 361.0;\n    const float cb = 35442.0 / 1805.0;\n    const float cc = 16061.0 / 1805.0;\n    float t2 = t * t;\n    return t < a\n    ? 7.5625 * t2\n    : t < b\n    ? 9.075 * t2 - 9.9 * t + 3.4\n    : t < c\n    ? ca * t2 - cb * t + cc\n    : 10.8 * t * t - 20.52 * t + 10.72;\n}\nfloat bounceIn(float t) {\n    return 1.0 - bounceOut(1.0 - t);\n}\nfloat bounceInOut(float t) {\n    return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\nfloat circularInOut(float t) {\n    return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\nfloat circularIn(float t) {\n    return 1.0 - sqrt(1.0 - t * t);\n}\nfloat circularOut(float t) {\n    return sqrt((2.0 - t) * t);\n}\nfloat cubicInOut(float t) {\n    return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\nfloat cubicIn(float t) {\n    return t * t * t;\n}\nfloat cubicOut(float t) {\n    float f = t - 1.0;\n    return f * f * f + 1.0;\n}\nfloat elasticInOut(float t) {\n    return t < 0.5\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\nfloat elasticIn(float t) {\n    return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\n}\nfloat elasticOut(float t) {\n    return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\nfloat expoInOut(float t) {\n    return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n    ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n    : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\nfloat expoIn(float t) {\n    return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\nfloat expoOut(float t) {\n    return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\nfloat linear(float t) {\n    return t;\n}\nfloat quadraticInOut(float t) {\n    float p = 2.0 * t * t;\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\nfloat quadraticIn(float t) {\n    return t * t;\n}\nfloat quadraticOut(float t) {\n    return -t * (t - 2.0);\n}\nfloat quarticInOut(float t) {\n    return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\nfloat quarticIn(float t) {\n    return pow(t, 4.0);\n}\nfloat quarticOut(float t) {\n    return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\nfloat qinticInOut(float t) {\n    return t < 0.5\n    ? +16.0 * pow(t, 5.0)\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\nfloat qinticIn(float t) {\n    return pow(t, 5.0);\n}\nfloat qinticOut(float t) {\n    return 1.0 - (pow(t - 1.0, 5.0));\n}\nfloat sineInOut(float t) {\n    return -0.5 * (cos(PI * t) - 1.0);\n}\nfloat sineIn(float t) {\n    return sin((t - 1.0) * HALF_PI) + 1.0;\n}\nfloat sineOut(float t) {\n    return sin(t * HALF_PI);\n}\n\nvoid main()\n{\n    gl_FragColor.rgb = mix(colorBg2, colorBg1, quadraticInOut(vUv.y));\n    gl_FragColor.a = 1.0;\n}\n"},function(e,n){e.exports="precision highp float;\nprecision highp int;\nattribute vec2 uv;\nattribute vec3 position;\nattribute vec3 normal;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nuniform vec3 colorCubes1;\nuniform vec3 colorCubes2;\n\nuniform mat4 shadowMatrix;\nuniform vec3 lightPosition;\nvarying vec4 shadowCoord;\n\nuniform vec3 mousePosition;\nuniform float touchRadius;\nuniform float touchForce;\nuniform float time;\nuniform float mouseSpeed;\n\nattribute vec3 offset;\n\nvarying vec2 vUv;\nvarying vec3 lPos;\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec3 cColor;\n\nvoid main()\n{\n    vUv = uv;\n    vec3 wPos = (modelMatrix * vec4(position, 1.0)).xyz + offset;\n    vec3 wCenter = (modelMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz + offset;\n    float d = 3.0;\n    vec3 wAuto = vec3(sin(time * 20.0) * d - sin(time) * d * 0.357, sin(time * 15.0 + 3.0) * d - sin(time * 25.0 - 2.45454), sin(time * 20.0 + 3.0) * 1.0);\n    vec3 mouseVector0 = wCenter.xyz - wAuto;\n    float mouseDist0 = 1.0 - smoothstep(0.0, touchRadius * 0.8, length(mouseVector0));\n    float disp0 = mouseDist0 * touchForce * 1.3;\n    vec3 influence0 = normalize(mouseVector0) * disp0;\n    wPos += influence0;\n    vec3 mouseVector = wCenter.xyz - mousePosition;\n    float mouseDist = (1.0 - smoothstep(0.0, touchRadius, length(mouseVector))) * mouseSpeed;\n    float disp = mouseDist * touchForce;\n    vec3 influence = normalize(mouseVector) * disp;\n    wPos += influence;\n    cColor = mix(colorCubes1, vec3(1.0), mouseDist);\n    cColor = mix(cColor, colorCubes2, clamp(mouseDist - 0.2, 0.0, 1.0));\n    cColor = mix(cColor, colorCubes2, mouseDist0);\n    shadowCoord = shadowMatrix * vec4(wPos, 1.0);\n    lPos = (viewMatrix * vec4(lightPosition, 1.0)).xyz;\n    vPos = (viewMatrix * vec4(wPos, 1.0)).xyz;\n    vNormal = normalize(normalMatrix * normal);\n    gl_Position = projectionMatrix * viewMatrix * vec4(wPos, 1.0);\n}\n"},function(e,n){e.exports="precision highp float;\nprecision highp int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nuniform float lightStr;\n\nuniform sampler2D shadowMap;\nuniform float shadowBias;\nuniform float shadowRadius;\nuniform vec2 shadowMapSize;\nuniform float borderMargin;\nuniform float shadowStr;\n\nvarying vec4 shadowCoord;\n\nvarying vec2 vUv;\nvarying vec3 vPos;\nvarying vec3 lPos;\nvarying vec3 vNormal;\nvarying vec3 cColor;\n\nconst float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n    return dot( v, UnpackFactors );\n}\n\nfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n    return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n}\n\nfloat getShadow(vec4 sCoord) {\n\n    float shadow = 1.0;\n\n    sCoord.xyz /= sCoord.w;\n    sCoord.z += shadowBias;\n\n    bvec4 inFrustumVec = bvec4 ( sCoord.x >= 0.0, sCoord.x <= 1.0, sCoord.y >= 0.0, sCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n\n    bvec2 frustumTestVec = bvec2( inFrustum, sCoord.z <= 1.0 );\n    bool frustumTest = all(frustumTestVec);\n\n    if(frustumTest)\n    {\n        vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n        float dx0 = - texelSize.x * shadowRadius;\n        float dy0 = - texelSize.y * shadowRadius;\n        float dx1 = + texelSize.x * shadowRadius;\n        float dy1 = + texelSize.y * shadowRadius;\n\n        shadow = (\n            texture2DCompare( shadowMap, sCoord.xy + vec2( dx0, dy0 ), sCoord.z ) +\n            texture2DCompare( shadowMap, sCoord.xy + vec2( 0.0, dy0 ), sCoord.z ) +\n            texture2DCompare( shadowMap, sCoord.xy + vec2( dx1, dy0 ), sCoord.z ) +\n            texture2DCompare( shadowMap, sCoord.xy + vec2( dx0, 0.0 ), sCoord.z ) +\n            texture2DCompare( shadowMap, sCoord.xy, sCoord.z ) +\n            texture2DCompare( shadowMap, sCoord.xy + vec2( dx1, 0.0 ), sCoord.z ) +\n            texture2DCompare( shadowMap, sCoord.xy + vec2( dx0, dy1 ), sCoord.z ) +\n            texture2DCompare( shadowMap, sCoord.xy + vec2( 0.0, dy1 ), sCoord.z ) +\n            texture2DCompare( shadowMap, sCoord.xy + vec2( dx1, dy1 ), sCoord.z )\n        ) * ( 1.0 / 9.0 );\n    }\n\n    return 1.0 - shadow;\n}\n\nfloat l(vec3 lightDirection, vec3 surfaceNormal)\n{\n    return max(0.0, dot(lightDirection, surfaceNormal));\n}\n\nvoid main()\n{\n    vec3 lDir = normalize(lPos - vPos);\n    vec3 normal = normalize(vNormal);\n    float s = l(lDir, normal) * lightStr + getShadow(shadowCoord) * shadowStr;\n    vec3 color = cColor - s;\n    gl_FragColor = vec4(color, 1.0);\n}\n"},function(e,n){e.exports="precision highp float;\nprecision highp int;\nattribute vec2 uv;\nattribute vec3 position;\nattribute vec3 normal;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nvarying vec2 vUv;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform vec2 resolution;\n\nvoid main() {\n  vUv = uv;\n  vec2 fragCoord = uv * resolution;\n  vec2 inverseVP = 1.0 / resolution.xy;\n  v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n  v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n  v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n  v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n  v_rgbM = vec2(fragCoord * inverseVP);\n\n  gl_Position = vec4(position,1.0);\n}\n"},function(e,n){e.exports="precision highp float;\nprecision highp int;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\n\nvarying vec2 vUv;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform vec2 resolution;\nuniform sampler2D tDiffuse;\n\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#define FXAA_SPAN_MAX     8.0\n\nfloat when_gt(float x, float y) {\n    return max(sign(x - y), 0.0);\n}\nfloat when_lt(float x, float y) {\n    return max(sign(y - x), 0.0);\n}\n\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE,\n            vec2 v_rgbSW, vec2 v_rgbSE,\n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n\n\n    color = vec4(rgbB, texColor.a);\n    color = mix(color, vec4(rgbA, texColor.a), when_lt(lumaB, lumaMin));\n    color = mix(color, vec4(rgbA, texColor.a), when_gt(lumaB, lumaMax));\n\n    return color;\n}\n\nvoid main() {\n  vec2 fragCoord = vUv * resolution;\n  gl_FragColor = fxaa(tDiffuse, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}\n"},,,,,function(e,n,t){},function(e,n,t){},function(e,n,t){"use strict";t.r(n);var o=t(13),c=(t(32),t(0)),i=t(14),r=t(6),s=t(3),u=t(28),l={main:null,rootUrl:null,appData:null,client:{browser:"",device:"",lang:"",os:"",sizes:{width:window.innerWidth,height:window.innerHeight},mousePosition:{x:0,y:0}}},a=t(15),m=t.n(a),f=(t(33),t(16)),d=t.n(f),h=t(17),v=t.n(h),p=t(18),w=t(29),g=t(21),b=t(22),x=t.n(b),y=t(23),C=t.n(y),S=t(24),M=t.n(S),P=t(25),z=t.n(P);function _(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}var U=function(){function o(e,n,t){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,o),this.camera=e,this.renderer=n,this.mainUniforms=t,this.scene=new c.v,this.createBg(),this.createCubes(),this.pass=new g.a(this.scene,this.camera),this.pass.setSize=function(e,n){},this.pass.renderToScreen=!1}var e,n,t;return e=o,(n=[{key:"createBg",value:function(){var e=new c.q(2,2);this.bgMaterial=new c.t({uniforms:{colorBg1:{value:new c.e(this.mainUniforms.colorBg1)},colorBg2:{value:new c.e(this.mainUniforms.colorBg2)},bgRotation:{value:this.mainUniforms.bgRotation*Math.PI/180}},vertexShader:x.a,fragmentShader:C.a}),this.bgMaterial.depthTest=!1,this.bgMaterial.depthWrite=!1;var n=new c.l(e,this.bgMaterial);n.frustumCulled=!1,n.renderOrder=-1,this.scene.add(n)}},{key:"createCubes",value:function(){var e=new c.a(this.mainUniforms.cubeSize,this.mainUniforms.cubeSize,this.mainUniforms.cubeSize),n=new c.h;n.addAttribute("position",e.attributes.position),n.addAttribute("normal",e.attributes.normal),n.addAttribute("uv",e.attributes.uv),n.groups=e.groups,n.setIndex(e.index);for(var t=[],o=0;o<16;o++)for(var a=0;a<16;a++)for(var r=0;r<16;r++){var i=(o-8)*this.mainUniforms.bigCubeSize/16,s=(a-8)*this.mainUniforms.bigCubeSize/16,u=(r-8)*this.mainUniforms.bigCubeSize/16;t.push(i,s,u)}n.addAttribute("offset",new c.g(new Float32Array(t),3,!1,1)),n.maxInstancedCount=4096,this.cubeMaterial=new c.t({uniforms:{colorCubes1:{value:new c.e(this.mainUniforms.colorCubes1)},colorCubes2:{value:new c.e(this.mainUniforms.colorCubes2)},lightPosition:{value:this.mainUniforms.lightPosition},lightStr:{value:this.mainUniforms.lightStr},shadowStr:{value:this.mainUniforms.shadowStr},mousePosition:{value:new c.z},touchRadius:{value:this.mainUniforms.touchRadius},touchForce:{value:this.mainUniforms.touchForce},time:{value:0},mouseSpeed:{value:0}},vertexShader:M.a,fragmentShader:z.a}),this.cubeMesh=new c.l(n,this.cubeMaterial),this.cubeMesh.frustumCulled=!1,this.scene.add(this.cubeMesh)}}])&&_(e.prototype,n),t&&_(e,t),o}();function A(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}var F=function(){function u(e){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:[],t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:[],o=3<arguments.length&&void 0!==arguments[3]?arguments[3]:new c.z,a=4<arguments.length&&void 0!==arguments[4]?arguments[4]:1024,r=5<arguments.length&&void 0!==arguments[5]?arguments[5]:5;!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,u),this.renderer=e,this.scene=new c.v;for(var i=0;i<n.length;i++)this.scene.add(n[i]);this.camera=new c.n(-r,r,r,-r,.001,1e3),this.camera.position.x=-o.x,this.camera.position.y=o.y,this.camera.position.z=-o.z,this.camera.target=new c.z(0,0,0),this.camera.lookAt(this.camera.target),this.camera.updateProjectionMatrix(),this.shadowMapSize=a,this.shadowMap=new c.A(this.shadowMapSize,this.shadowMapSize,{wrapS:c.d,wrapT:c.d,minFilter:c.m,magFilter:c.m,format:c.s,stencilBuffer:!1,depthBuffer:!0}),this.recieveShadowObjects=[];for(var s=0;s<t.length;s++)t[s].material.uniforms.shadowMap={value:this.shadowMap.texture},t[s].material.uniforms.shadowMapSize={value:new c.y(this.shadowMapSize,this.shadowMapSize)},t[s].material.uniforms.shadowMatrix={value:new c.k},t[s].material.uniforms.shadowBias={value:.01},t[s].material.uniforms.shadowRadius={value:5},this.recieveShadowObjects.push(t[s]);this.shadowMatrix=new c.k,this.clearColor=new c.e("#FFFFFF"),this.clearAlpha=1}var e,n,t;return e=u,(n=[{key:"updateShadowMatrix",value:function(){this.shadowMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.shadowMatrix.multiply(this.camera.projectionMatrix),this.shadowMatrix.multiply(this.camera.matrixWorldInverse);for(var e=0;e<this.recieveShadowObjects.length;e++)this.recieveShadowObjects[e].material.uniforms.shadowMatrix.value.copy(this.shadowMatrix)}},{key:"setShadowBias",value:function(e,n){this.recieveShadowObjects[e].material.uniforms.shadowBias.value=n}},{key:"setShadowRadius",value:function(e){for(var n=0;n<this.recieveShadowObjects.length;n++)this.recieveShadowObjects[n].material.uniforms.shadowRadius.value=e}},{key:"render",value:function(){var e=this.renderer.autoClear,n=this.renderer.getClearColor().getHex(),t=this.renderer.getClearAlpha();this.renderer.autoClear=!1,this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.renderer.render(this.scene,this.camera,this.shadowMap,!0),this.renderer.setClearColor(n,t),this.renderer.autoClear=e,this.updateShadowMatrix()}}])&&A(e.prototype,n),t&&A(e,t),u}(),R=t(4),D=t(26),O=t.n(D),k=t(27),E=t.n(k);var V=function e(){var t=this;!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.material=new c.t({uniforms:{tDiffuse:{value:null},resolution:{value:new c.y}},vertexShader:O.a,fragmentShader:E.a}),this.material.depthWrite=!1,this.material.depthTest=!1,this.pass=new R.a(this.material),this.pass.setSize=function(e,n){t.material.uniforms.resolution.value.x=e,t.material.uniforms.resolution.value.y=n},this.pass.needsSwap=!0,this.pass.renderToScreen=!0};function I(e){return(I="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function N(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}function B(e,n){return!n||"object"!==I(n)&&"function"!=typeof n?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):n}function j(e){return(j=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function W(e,n){return(W=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var T=function(e){function a(e,n,t){var o;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,a),(o=B(this,j(a).call(this,{eventHub:{},store:l,router:{resize:function(){}},url:e,client:n,appData:t,appType:"DESKTOP",templateFunction:m.a}))).mainUniforms={lightPosition:new c.z(11,6,-7),colorBg1:"#505761",colorBg2:"#32363c",bgRotation:81,colorCubes1:"#84222e",colorCubes2:"#d4aa20",lightStr:.15,shadowCameraPosition:new c.z(11,6,-7),shadowBias:-25e-6,shadowRadius:.8,shadowStr:.2,cubeSize:.2,bigCubeSize:4.5,touchRadius:3.5,touchForce:1.3},o}var n,t,o;return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&W(e,n)}(a,u["a"]),n=a,(t=[{key:"setup",value:function(){var e=this;this.renderer=new c.B({canvas:document.querySelector("canvas"),antialias:!1,transparent:!0}),this.renderer.setClearColor(this.mainUniforms.colorBg),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.autoClear=!1,this.camera=new c.o(45,this.store.client.sizes.width/this.store.client.sizes.height,.01,100),this.camera.target=new c.z(0,0,0),this.camera.position.set(8,6,10),this.camera.lookAt(this.camera.target),"mobile"!==this.store.client.device?(this.controls=new p.a(this.camera,document.querySelector("canvas")),this.controls.enableDamping=!0,this.controls.dampingFactor=.15,this.controls.maxDistance=15):this.controls={update:function(){}},this.effectComposerScene=new w.a(this.renderer),this.passScene=new U(this.camera,this.renderer,this.mainUniforms),this.passFXAA=new V,this.effectComposerScene.addPass(this.passScene.pass),this.effectComposerScene.addPass(this.passFXAA.pass),this.createShadowRenderer(),this.createGui(),this.rayCaster=new c.u,this.mousePosition=new c.y(-1,-1),this.prevPosition=new c.y,this.speed=0,this.events.add(document,"mousemove",this.move,this),this.events.add(document,"touchmove",this.move,this);var n=new c.z(0,0,0),t=new c.z,o=new c.p;Object(r.a)(-1,function(){e.controls.update(),e.speed+=2.3*e.mousePosition.distanceTo(e.prevPosition),e.speed=s.a.clamp(s.a.round(.97*e.speed,4),0,1),e.passScene.cubeMaterial.uniforms.mouseSpeed.value=e.speed,e.shadowCubeMaterial.uniforms.mouseSpeed.value=e.speed,e.prevPosition.copy(e.mousePosition),e.rayCaster.setFromCamera(e.mousePosition,e.camera),n.copy(e.camera.position).normalize().multiplyScalar(2),o.setFromNormalAndCoplanarPoint(e.camera.position,n),e.rayCaster.ray.intersectPlane(o,t),e.animateMousePosition(t),e.shadowCubeMaterial.uniforms.time.value+=.001,e.passScene.cubeMaterial.uniforms.time.value=e.shadowCubeMaterial.uniforms.time.value,e.shadowRenderer.render(),e.effectComposerScene.render()})}},{key:"move",value:function(e){var n=e.targetTouches?e.targetTouches[0]:e;this.mousePosition.x=n.clientX/this.store.client.sizes.width*2-1,this.mousePosition.y=-1*(n.clientY/this.store.client.sizes.height*2-1)}},{key:"animateMousePosition",value:function(e){Object(r.b)([this.passScene.cubeMaterial.uniforms.mousePosition.value,this.shadowCubeMaterial.uniforms.mousePosition.value],.35,{x:e.x,y:e.y,z:e.z},{immediate:!0,ease:"P3.out",overwrite:!0},0)}},{key:"createGui",value:function(){var n=this,e=new i.a,t=e.addFolder("Colors");t.closed=!1,t.addColor(this.mainUniforms,"colorBg1").onChange(function(e){n.passScene.bgMaterial.uniforms.colorBg1.value=new c.e(e)}),t.addColor(this.mainUniforms,"colorBg2").onChange(function(e){n.passScene.bgMaterial.uniforms.colorBg2.value=new c.e(e)}),t.add(this.mainUniforms,"bgRotation",0,360).onChange(function(e){n.passScene.bgMaterial.uniforms.bgRotation.value=e*Math.PI/180}),t.addColor(this.mainUniforms,"colorCubes1").onChange(function(e){n.passScene.cubeMaterial.uniforms.colorCubes1.value=new c.e(e)}),t.addColor(this.mainUniforms,"colorCubes2").onChange(function(e){n.passScene.cubeMaterial.uniforms.colorCubes2.value=new c.e(e)});var o=e.addFolder("Light");o.add(this.mainUniforms.lightPosition,"x",-30,30),o.add(this.mainUniforms.lightPosition,"y",-30,30),o.add(this.mainUniforms.lightPosition,"z",-30,30),o.add(this.mainUniforms,"lightStr",0,1).onChange(function(e){n.passScene.cubeMaterial.uniforms.lightStr.value=e});var a=e.addFolder("Shadow");a.add(this.mainUniforms.shadowCameraPosition,"x",-30,30).onChange(function(e){n.shadowRenderer.camera.position.x=-e,n.shadowRenderer.camera.lookAt(n.shadowRenderer.camera.target)}),a.add(this.mainUniforms.shadowCameraPosition,"y",-30,30).onChange(function(e){n.shadowRenderer.camera.position.y=e,n.shadowRenderer.camera.lookAt(n.shadowRenderer.camera.target)}),a.add(this.mainUniforms.shadowCameraPosition,"z",-30,30).onChange(function(e){n.shadowRenderer.camera.position.z=-e,n.shadowRenderer.camera.lookAt(n.shadowRenderer.camera.target)}),a.add(this.mainUniforms,"shadowBias",-.001,.001).onChange(function(e){n.shadowRenderer.setShadowBias(0,e),console.log("bias: "+e)}),a.add(this.mainUniforms,"shadowRadius",0,5).onChange(function(e){n.shadowRenderer.setShadowRadius(e)}),a.add(this.mainUniforms,"shadowStr",0,1).onChange(function(e){n.passScene.cubeMaterial.uniforms.shadowStr.value=e});var r=e.addFolder("Interaction");r.closed=!1,r.add(this.mainUniforms,"touchRadius",.1,10).onChange(function(e){n.passScene.cubeMaterial.uniforms.touchRadius.value=e,n.shadowCubeMaterial.uniforms.touchRadius.value=e}),r.add(this.mainUniforms,"touchForce",.1,4).onChange(function(e){n.passScene.cubeMaterial.uniforms.touchForce.value=e,n.shadowCubeMaterial.uniforms.touchForce.value=e}),e.close()}},{key:"createShadowRenderer",value:function(){var e=this.passScene.cubeMesh.geometry.clone();this.shadowCubeMaterial=new c.t({uniforms:{mousePosition:{value:new c.z},touchRadius:{value:this.mainUniforms.touchRadius},touchForce:{value:this.mainUniforms.touchForce},time:{value:0},mouseSpeed:{value:0}},vertexShader:v.a,fragmentShader:d.a}),this.shadowCube=new c.l(e,this.shadowCubeMaterial),this.shadowCube.frustumCulled=!1,this.shadowRenderer=new F(this.renderer,[this.shadowCube],[this.passScene.cubeMesh],this.mainUniforms.lightPosition,2048,8),this.shadowRenderer.setShadowBias(0,this.mainUniforms.shadowBias),this.shadowRenderer.setShadowRadius(this.mainUniforms.shadowRadius)}},{key:"resize",value:function(e,n){this.renderer&&(this.camera.aspect=this.store.client.sizes.width/this.store.client.sizes.height,this.camera.updateProjectionMatrix(),this.renderer.setSize(this.store.client.sizes.width,this.store.client.sizes.height),this.effectComposerScene&&this.effectComposerScene.setSize(this.store.client.sizes.width,this.store.client.sizes.height))}}])&&N(n.prototype,t),o&&N(n,o),a}();function q(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}var X=window.location.protocol+"//"+window.location.host,L={lang:"",os:"",device:"",browser:""},H=o.a.getParser(window.navigator.userAgent).parsedResult,G=function(){function e(){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.detectOS(),this.detectDevice(),this.addClasses(),this.initApp(),this.sayHello()}var n,t,o;return n=e,(t=[{key:"detectOS",value:function(){switch(H.os.name.toLowerCase()){case"macos":L.os="mac";break;case"ios":L.browser="ios";break;default:L.browser="windows"}}},{key:"detectDevice",value:function(){switch(L.device="desktop"===H.platform.type?"desktop":"mobile",H.browser.name){case"Internet Explorer":L.browser="explorer";break;case"Microsoft Edge":L.browser="edge";break;case"Firefox":L.browser="firefox";break;case"Safari":L.browser="safari";break;default:L.browser="chrome"}}},{key:"addClasses",value:function(){var e=document.querySelector("html");for(var n in L)L[n]&&e.classList.add(L[n])}},{key:"initApp",value:function(e){new T(X,L,{}).render()}},{key:"sayHello",value:function(){if("chrome"===L.browser||"firefox"===L.browser){window.console.log.apply(console,["%c Developed by @vlucendo - http://vlucendo.com ","display: block; padding: 5px; background: #351330; line-height: 40px; color: #ffffff;"])}else window.console.log("Developed by @vlucendo - http://vlucendo.com")}}])&&q(n.prototype,t),o&&q(n,o),e}();"loading"!==document.readyState?new G:document.addEventListener("DOMContentLoaded",function(){new G},!1)}]);